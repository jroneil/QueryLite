# QueryLite Debugging & Architecture Guide: Middleware & CORS

This document serves as a reference for resolving recurring issues related to CORS, middleware ordering, and error masking encountered during the development of QueryLite.

## 1. The "Masked CORS Error" Issue

### The Problem
When the frontend receives a `TypeError: Failed to fetch` or a "CORS policy blocked" message in the console, it often **hides the true server error**. This happens because:
1. A server-side error occurs (e.g., 400 Bad Request or 500 Internal Server Error).
2. The server generates an error response.
3. If the CORS middleware is not correctly ordered, it may fail to add the `Access-Control-Allow-Origin` headers to that specific error response.
4. The browser, seeing a response without CORS headers from a different origin, blocks it entirely.
5. The developer only sees "CORS error" instead of the actual validation or logic error.

### The Solution: Correct Middleware Ordering
In FastAPI, the order in which you wrap the application with middleware is critical. **CORS must be the outermost layer** to ensure it intercepts every single response, including those generated by `ExceptionHandlers` or other middlewares.

#### In `app/main.py`:
```python
# 1. First, add application-level logic middlewares
app.middleware("http")(error_handler_middleware)
app.middleware("http")(rate_limit_middleware)

# 2. FINALLY, add CORSMiddleware
# This ensures CORS is the LAST thing to process the response
# making it the 'outermost' layer.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", ...],
    ...
)
```

---

## 2. Common Validation Errors (Pydantic)

A frequent cause of the 400 errors masked by CORS is **Pydantic Validation**. 

### Example: The "Area Chart" Case
- **Trigger**: The backend `QueryExecutor` recommended an `'area'` type.
- **Error**: `ChartRecommendation.chart_type String should match pattern '^(bar|line|donut|table)$'`.
- **Result**: Pydantic threw a `ValidationError`, which reached the top level without CORS headers, causing a "CORS error" in the browser.

### Prevention
- Always ensure frontend interfaces (TypeScript) and backend schemas (Pydantic) are synchronized when adding new features (like new chart types or report fields).

---

## 3. Response Validation Errors (FastAPI)

### The Problem
If you see an **Internal Server Error (500)** in the console and the backend logs show `fastapi.exceptions.ResponseValidationError`, it means the data returned by your route function does not match the `response_model` defined in the decorator.

### Common Cause: DB Driver Inconsistencies
In QueryLite, we use `JSON` columns for things like `recipient_emails`. Some database drivers or configurations might return this data as a **JSON-encoded string** instead of a Python list when fetching records.

**Error Message:**
`{'type': 'list_type', 'loc': ('response', 'recipient_emails'), 'msg': 'Input should be a valid list', 'input': '["user@example.com"]'}`

### The Solution: Smart Pydantic Validators
Use a `before` validator in your Pydantic schema to automatically parse strings into the expected type:

```python
from pydantic import field_validator
import json

class MyResponseModel(BaseModel):
    my_list: List[str]

    @field_validator("my_list", mode="before")
    @classmethod
    def validate_list(cls, v):
        if isinstance(v, str):
            try:
                return json.loads(v)
            except:
                return [v] # Fallback
        return v
```

---

## 4. Debugging Checklist

If you see a `Failed to fetch` error in the frontend console:

1.  **Check Backend Logs**: Look at the Docker/Python console output. It will show the real exception (e.g., `pydantic.v2.errors.PydanticSerializationError`).
2.  **Verify Middleware Order**: Ensure `CORSMiddleware` is visually the **last** one added in `main.py`.
3.  **Inspect Network Tab**: Look for the specific status code. If it's 400 or 500 but has no "Response" body in the browser, it confirms the "CORS masking" is happening.
4.  **Whitelisting**: Ensure any new enum values (like a new `chart_type`) are added to `backend/app/models/schemas.py`.

## 4. Why This Recurring Issue Happens
As we build new features (Shared Workspaces, Scheduled Reports, new Chart types), we frequently introduce new data formats. If the backend schema isn't updated simultaneously with the engine logic, Pydantic will block the request. Because of step #1 (Middleware Masking), this used to show up as a CORS issue, making it harder to track down.

**Fixing the middleware order in `app/main.py` is the permanent fix to make these errors visible and actionable.**
